The Meteor framework is specifically designed for creating easily extendable, customizable, and maintainable business software systems for small businesses.

Meteor has been architected with several goals in mind.
Each of the design goals discussed below has been adopted in order to either reduce the cost of creating or assembling business systems, to
increase the revenues generated by modules, or to reduce costs to businesses that buy and use systems.
The details of how to create Meteor-based systems are covered in Meteor's technical documentation.
However, it is important to understand that these design choices were adopted in order to meet Meteor's
business goal of profitably producing high-quality software for small businesses. Meteor was initially designed for use in the BizBlocs business system.

### Dynamic, modular system assembly ###

All functionality and metadata is packaged into self-contained modules that are assembled into software systems.
New modules containing additional functionality or customizations of existing funnctionality may be dynamically added to a system without technical assistance.
Similarly, all modules in a system may be dynamically updated and/or removed without technical assistance.

Modular assembly of systems reduces costs for small businesses in a couple of ways:
  * It enables systems to be updated and extended without the need for consultants or technical specialists.
  * It fosters competition between vendors since businesses may mix extensions from many vendors and are not tied to any single vendor.
Modular assembly of systems can also increase the quality of software
systems by allowing businesses to chose 'best-of-breed' modules instead of
being bound to any one vendor.

### Model-driven engineering ###

Meteor provides a global metadata repository.
A global metadata repository makes it possible for a module to implement
entire system aspects like workflows, or a user interface.
Modules contribute metadata to the repository that describes a particular
aspect of the system, such as the user interface, or workflow.
Other modules use metadata in the repository to implement the associated
system aspect.

Model-driven engineering significantly reduces the cost of module development
for vendors since it eliminates the need for vendors to develop common
system aspects like persistence, or user-interface elements.
Model-driven engineering also makes modules more reusable since modules
are not tied to any particular implementation of a system aspect.

### Unanticipated customization, or customization without hooks ###

All functionality must be customizable without requiring vendors to build customization hooks into their modules.
Many software framework enable customization by requiring developers to build 'hooks or 'extension points'
into thier modules.  The problem with this is that it limits reusability and customization to only what
vendors anticipate and bother to provide hooks for.  Meteor takes a more 'aspect-oriented' approach to
customization that enables customization with requiring built-in hooks.

Customization without hooks can reduce costs for businesses by making it possible to create
customized software with significantly less labor than other customization methods.

Customization without hooks reduces the cost of module development
for vendors since it makes other modules easier to resuse and eliminates much of the labor
required by other customization methods.

Customization without hooks increases the revenue that can be generated from a module
since it make it possible to reuse modules in ways that were not anticipated by the modules vendor.

### Provide the most common system functionality out-of-the-box ###

Meteor itself implements many aspects out of the box, like user
authentication and authorization, data storage, and user interface.
Developers should not have to concern themselves with common system aspects but
should be able to focus on business functionality. This is critical to making
Meteor a low-cost development choice.

## Comparison to other frameworks ##

Many frameworks (like Ruby On Rails, Grails) are created with only the goal of
making software development easier and less expensive, but they don't address software reuse,
maintenance, or customization issues thus making software prohibitively
expensive to maintain and customize.

Some existing frameworks (like Compiere ERP) enable model-driven development but don't support dynamic modularization, thus making
software prohibitively expensive by requiring engineers to apply updates,
customizations, and extensions.

Some frameworks support dynamic modularization but require vendors to
build hooks into thier modules in order to make it possible to customize them (like Drupal, Sugar CRM, Tiny ERP),
thus increasing the cost of creating modules or reducing the possibility of reusing modules.

Many/Most frameworks have no system model nor any method of enabling a module to
implement a system aspect like security and UI.  Most frameworks have some system
aspects built into the framework but those implementations are not substitutable,
thus limiting the resulting system to only what is in the framework. For instance,
if the framework does not provide security authorization then each module must
handle that themselves.
In contrast, Meteor's system functionality, like its UI for instance, can be
removed and replaced by other modules that implement the UI in a completely
different manner, thus making a Meteor-based system much more reusable.
Also, any system aspect that Meteor does not supply out-of-the-box may be
implemented by a thord-party and added into Meteor.

Meteor is designed to bring it all together:
modular software assembly, model-driven system aspects, unanticipated customization, and
a lot of common functionality out of the box.