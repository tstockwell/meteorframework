package sat.solver;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.SQLException;
import java.util.HashMap;

import sat.Constant;
import sat.Formula;
import sat.Implication;
import sat.Negation;
import sat.PropositionalSystem;
import sat.Variable;
import sat.ruledb.RuleDatabase;
import sat.ruledb.TruthTables;
import sat.utils.ArgUtils;

/**
 * A tool for determining the satisfiability of boolean expressions 
 * using the reduction rule database generated by sat.ruledb.RuleGenerator.
 * 
 * @author Ted Stockwell <emorning@yahoo.com>
 */
public class Solver {
	
	public static void main(String[] args) throws IOException, SQLException {
		PropositionalSystem system= new PropositionalSystem();
		TruthTables truthTables= new TruthTables(system);
		String file= ArgUtils.getString(args, "file", true);
		CNFFile cnf= CNFFile.read(system, new FileInputStream(file));
		
		Solver solver= new Solver(system, new RuleDatabase(truthTables));
		Formula reducedForm= solver.reduce(cnf.getFormula());
		
		// produce output according to rules here:
		// 	http://www.satcompetition.org/2004/format-solvers2004.html
		int status;
		if (Constant.FALSE.equals(reducedForm)) {
			System.out.println("s UNSATISFIABLE");
			status= 20;
		}
		else {
			System.out.println("s SATISFIABLE");
			printSatisfyingValuation(reducedForm);
			status= 10;
		}
		System.exit(status);
	}
	
	private PropositionalSystem _system;
	private RuleDatabase _ruleDatabase; 
	public Solver(PropositionalSystem system, RuleDatabase ruleDatabase) { 
		_system= system;
		_ruleDatabase= ruleDatabase;
	}
	
	

	private static void printSatisfyingValuation(Formula reducedForm) {
		// TODO Auto-generated method stub
		
	}

	public Formula reduce(Formula formula) {
		if (formula instanceof Negation) {
			Formula subformula= ((Negation)formula).getChild();
			Formula reduced= reduce(subformula);
			if (reduced != subformula)
				formula= _system.createNegation(reduced);
			return applyRules(formula);
		}
		if (formula instanceof Implication) {
			Implication implication= (Implication)formula;
			Formula antecent= implication.getAntecedent();
			Formula consequent= implication.getConsequent();
			Formula a= reduce(antecent);
			Formula c= reduce(consequent);
			if (a != antecent || c != consequent)
				formula= _system.createImplication(a, c);
			return applyRules(formula);
		}
		return formula; // the given formula is a variable or constant
	}
	
	/**
	 * Only applies rules to the given formula, not subformulas
	 * @returns the reduced rule if a rule applied, else the given rule.
	 */
	private Formula applyRules(Formula formula) {
		RuleDatabase.Navigator navigator= _ruleDatabase.getNonCanonicalFormulaNavigator();
		try {
			while (navigator.hasNext()) {
				Formula reducableFormula= navigator.next();
				HashMap<Variable, Formula> substitutions= new HashMap<Variable, Formula>();
				int i= reducableFormula.subsumes(formula, substitutions);
				if (i < 0) {
					Formula canonicalForm= _ruleDatabase.findCanonicalFormula(reducableFormula);
					Formula reducedFormula= _system.createFormula(canonicalForm, substitutions);
					return reducedFormula;
				}
				navigator.advanceFromPosition(i);
			}
		}
		finally {
			navigator.close();
		}
		return formula;
		
	}
}
